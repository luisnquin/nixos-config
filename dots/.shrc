#!/bin/bash
# sh is too limited and also it requires all my code to change unnecessarilly

google() {
    search=""
    for term in "$@"; do search="$search%20$term"; done
    xdg-open "http://www.google.com/search?q=$search"
}

emoji() {
    emojis=(ðŸ ðŸ ðŸ¥ž ðŸ¥— ðŸ§‹ ðŸ ðŸ‚ ðŸƒ ðŸŒ±)

    month_nb=$(date +%m)

    case $month_nb in
    1 | 2) # Summer
        emojis+=(ðŸš ðŸŒ´ ðŸ¹ ðŸŒ» ðŸŠ â˜€ï¸ ðŸ‘™)

        # Valentine's month
        if [[ $month_nb -eq 2 ]]; then
            emojis+=(ðŸ’ž ðŸ« ðŸ§¸ ðŸ’ ðŸŒ¹ ðŸ’Œ)
        fi

        ;;
    3 | 4 | 5) # Spring
        emojis+=(ðŸ£ ðŸŒ³ ðŸ€ ðŸƒ ðŸŒˆ ðŸŒ· ðŸ ðŸ‡)

        ;;
    9 | 11) # Autumn
        emojis+=(ðŸ‚ ðŸ¥® â˜• ðŸŒ° ðŸŠ)

        if [[ $month_nb -eq 11 ]]; then
            emojis+=(ðŸŽ‚ ðŸ° ðŸŽ ðŸŽ‰ ðŸŽˆ)
        fi

        ;;
    10) # Halloween
        emojis+=(ðŸˆâ€â¬› ðŸ¦‡ ðŸ•·ï¸ ðŸ¥€ ðŸ¬ ðŸ« ðŸŽƒ ðŸ­ âš°ï¸ ðŸª¦ ðŸ«€)

        ;;
    12) # Christmas
        emojis+=(ðŸ· ðŸŽ ðŸŽ„ â˜ƒï¸ â„ï¸ ðŸ¥› ðŸ¦Œ) ;;
    esac

    printf "%s\n" "${emojis[$((RANDOM * ${#emojis[@]} / 32767))]}"
}

upload_img() {
    local image_path=$1

    # Check that the image path is valid
    if ! test -f "$image_path"; then
        printf "Error: '%s' is not a valid image file\n" "$image_path" >&2
        return 1
    fi

    # Make the POST request to the imgbb API
    response=$(curl -f -H "Content-Type: multipart/form-data" \
        -F "image=@$image_path" \
        -X POST "https://api.imgbb.com/1/upload?key=72fd020dc10851413f82a48f9318faa6")

    # Check if the request was successful
    if ! jq -e '.success' <<<"$response" >/dev/null; then
        printf "Error: failed to upload image\n\nResponse: %s\n" "$response" >&2

        return 1
    fi

    # Extract the image URL from the response
    image_url=$(jq -r '.data.url' <<<"$response")

    printf "%s\n" "$image_url"
}

gbh() {
    typeset -gA branch_color
    branch_color=(
        ["refactor/*"]="\033[38;2;70;117;90m"
        ["security/*"]="\033[38;2;196;35;57m"
        ["chore/*"]="\033[38;2;237;40;158m"
        ["perf/*"]="\033[38;2;40;237;122m"
        ["dev/*"]="\033[38;2;121;48;230m"
        ["feat/*"]="\033[0;92m"
        ["fix/*"]="\033[0;93m"
        ["master"]="\033[0;94m"
        ["main"]="\033[0;94m"
    )

    branch_keys=("feat/*" "fix/*" "refactor/*" "dev/*" "security/*" "perf/*" "chore/*" "master" "main")

    current_branch=$(git branch --show-current)

    git for-each-ref --color=always --sort=-committerdate \
        --format='%(HEAD) %(refname:short) %(color:reset)' refs/heads/ | while read -r branch; do
        if [[ $branch == *"*"* ]]; then
            branch="${branch#* }"
        fi

        for pattern in "${branch_keys[@]}"; do
            if [[ $branch =~ $pattern ]]; then
                frags=($(echo "$branch" | tr '/' ' '))

                if [ ${#frags[@]} = 3 ]; then
                    if [[ "$branch" =~ $current_branch ]]; then
                        branch="${branch_color[$pattern]}${frags[1]}/\033[0m${frags[2]} \033[38;2;93;201;196mâ† current\033[0m"
                    else
                        branch="${branch_color[$pattern]}${frags[1]}/\033[0m${frags[2]}"
                    fi
                else
                    if [[ "$branch" =~ $current_branch ]]; then
                        branch="${branch_color[$pattern]}${frags[1]}\033[0m \033[38;2;93;201;196mâ† current\033[0m"
                    else
                        branch="${branch_color[$pattern]}${frags[1]}\033[0m"
                    fi
                fi

                break
            fi
        done

        echo "$branch"
    done
}

billboard() {
    city=$(echo "$1" | xargs | tr '[:upper:]' '[:lower:]')

    get_available_cities() {
        curl --silent http://www.cinerama.com.pe/cines |
            htmlq --pretty .row .container .card .row .col-md-8 .card-body .btn --attribute href |
            awk '{sub("cartelera_cine/",""); print}' | tr '\n' ' '
    }

    # Returns options in case of no passed argument
    if [ -z "$city" ]; then
        cities=($(get_available_cities | tr '\n' ' '))

        printf "\033[0;38;2;255;110;114mNo argument provided ðŸ”¥, options:\n"

        for city in "${cities[@]}"; do
            city=$(echo "$city" | sed 's/.*/\L&/; s/[a-zÃ±]*/\u&/g')
            echo " - ${city}"
        done

        printf "\033[0m"

        return 1
    fi

    cinerama_response=$(curl -s -X GET "http://www.cinerama.com.pe/cartelera_cine/$city")
    cinerama_raw_movies=$(echo "$cinerama_response" | htmlq --text .row .container .card .card-header | sed 's/.*/\L&/; s/[a-zÃ±]*/\u&/g')

    declare -a cinerama_movies_schedules
    index=1

    while read -r schedule; do
        # Sometimes at dawn there's nothing added for the current day
        if [[ "$schedule" == "" ]]; then
            break
        fi

        schedule_timestamp=$(date --date "$schedule" +%s)
        latest_schedules=($(echo "${cinerama_movies_schedules[-1]}" | tr ',' ' '))
        last_unix_schedule=$(date --date "${latest_schedules[-1]}" +%s)

        if [ -z "${latest_schedules[-1]}" ]; then # if last_unix_schedule is null
            cinerama_movies_schedules+=("$(date -d @"$schedule_timestamp" +'%H:%M')")

            continue
        fi

        if [[ $schedule_timestamp > $last_unix_schedule ]]; then
            latest_schedules+=($(date -d @"$schedule_timestamp" +'%H:%M'))
            cinerama_movies_schedules[index]=$(printf '%s\n' "$(IFS=, printf '%s' "${latest_schedules[*]}")")
        else
            cinerama_movies_schedules+=($(date -d @"$schedule_timestamp" +'%H:%M'))
            index=$((index + 1))
        fi

    done <<<"$(echo "$cinerama_response" | htmlq --text .row .container .card .row .col-md-9 .card-body .row .ml-1)"

    printf "\033[38;2;224;29;81mî¬¨ Cinerama:\033[0m\n"
    index=1

    while read -r movie; do
        schedules="${cinerama_movies_schedules[$index]}"

        if [[ "$schedules" == "" ]]; then
            schedules="(not available)"
        fi

        printf " \033[38;2;235;229;66mï……\033[0m %-50s %s\n" "$movie" "$schedules"
        index=$((index + 1))
    done <<<"$cinerama_raw_movies"
}

function hex2ansi() {
    local hex=${1}

    if [[ $hex =~ ^#[0-9A-Fa-f]{6}$ ]]; then
        r=$(printf '%d' 0x"${hex:1:2}")
        g=$(printf '%d' 0x"${hex:3:2}")
        b=$(printf '%d' 0x"${hex:5:2}")

        echo -e "\033[38;2;$r;$g;${b}mplaceholder\033[0m" | command xclip -selection clip
        echo -e "\033[38;2;$r;$g;${b}mCopied to clipboard! ïƒ†\033[0m"
    else
        printf "\033[38;2;240;91;106mInvalid hex color code\033[0m\n"

        return 1
    fi
}

remove_node_modules() {
    find . -name "node_modules" -type d -prune -exec rm -rf {} \;
}

take() {
    mkdir -p "$1"
    cd "$1" || return 1
}

if echo "$(ps -p$$ -ocmd=)" | grep -q "zsh"; then
    hsi() {
        grep "$*" ~/.zsh_history
    }
fi

pill() {
    environment_file="/home/$USER/.cache/environment-info.json"

    connection_info=$(cat "$environment_file" | jq -r '"\(if .connection.under_a_vpn then "ïˆ› under a vpn" else "îª­ no vpn" end), \(.connection.ip_address)"')
    weather_info=$(cat "$environment_file" | jq -r '"ðŸŒ¤ \(.weather.feels_like)Â° \(.weather.text)"')
    disk_stats=($(df / -h --output=size,used,pcent | sed -n '2p' | awk '{print $1,$2,$3}'))
    nixos_version=$(nixos-version | grep -o -E '^[0-9]+\.[0-9]+')
    nix_version=$(nix --version | grep -oP '\d+\.\d+')
    nb_of_failed_units=$(systemctl --failed | grep -c "failed")
    day=$(LC_TIME=en_US.UTF-8 date +%A)
    kernel_info=$(uname -smr)

    printf "\033[38;2;206;232;74mó°˜š $kernel_info\033[0m | \033[38;2;126;51;255mïŒ“ NixOS v$nixos_version / Nix v$nix_version\033[0m %-59s \033[38;2;255;162;13m$connection_info\033[0m\n"
    printf "$day, ${weather_info} %-96s"
    echo "${disk_stats[3]} - ${disk_stats[1]}/${disk_stats[2]}"

    if [[ $nb_of_failed_units != "0" ]]; then printf "%-118s\033[38;2;224;45;60m$nb_of_failed_units failed units\033[0m\n"; else echo; fi

    while read -r channel; do
        frags=($(echo "$channel" | tr ' ' '\n'))
        printf "\033[38;2;114;243;247m<-%s\033[0m \033[38;2;220;130;255m%s\033[0m\n" "${frags[1]}" "${frags[2]}"
    done <<<"$(nix-channel --list)"
}

# This trick isn't working, lol
# if ! test -e /tmp/.info_message_displayed && [ "$TERM_PROGRAM" != "vscode" ]; then
#     pill
#
#     echo "" >/tmp/.info_message_displayed
# fi
