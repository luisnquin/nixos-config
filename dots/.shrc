#!/bin/bash
# sh is too limited and also it requires all my code to change unnecessarilly

google() {
    search=""
    for term in "$@"; do search="$search%20$term"; done
    xdg-open "http://www.google.com/search?q=$search"
}

emoji() {
    emojis=(🍍 🍝 🥞 🥗 🧋 🍁 🍂 🍃 🌱)

    month_nb=$(date +%m)

    case $month_nb in
    1 | 2) # Summer
        emojis+=(🐚 🌴 🍹 🌻 🏊 ☀️ 👙)

        # Valentine's month
        if [[ $month_nb -eq 2 ]]; then
            emojis+=(💞 🍫 🧸 💐 🌹 💌)
        fi

        ;;
    3 | 4 | 5) # Spring
        emojis+=(🐣 🌳 🍀 🍃 🌈 🌷 🐝 🐇)

        ;;
    9 | 11) # Autumn
        emojis+=(🍂 🥮 ☕ 🌰 🍊)

        if [[ $month_nb -eq 11 ]]; then
            emojis+=(🎂 🍰 🎁 🎉 🎈)
        fi

        ;;
    10) # Halloween
        emojis+=(🐈‍⬛ 🦇 🕷️ 🥀 🍬 🍫 🎃 🍭 ⚰️ 🪦 🫀)

        ;;
    12) # Christmas
        emojis+=(🍷 🎁 🎄 ☃️ ❄️ 🥛 🦌) ;;
    esac

    printf "%s\n" "${emojis[$((RANDOM * ${#emojis[@]} / 32767))]}"
}

upload_img() {
    local image_path=$1

    # Check that the image path is valid
    if ! test -f "$image_path"; then
        printf "Error: '%s' is not a valid image file\n" "$image_path" >&2
        return 1
    fi

    # Make the POST request to the imgbb API
    response=$(curl -f -H "Content-Type: multipart/form-data" \
        -F "image=@$image_path" \
        -X POST "https://api.imgbb.com/1/upload?key=72fd020dc10851413f82a48f9318faa6")

    # Check if the request was successful
    if ! jq -e '.success' <<<"$response" >/dev/null; then
        printf "Error: failed to upload image\n\nResponse: %s\n" "$response" >&2

        return 1
    fi

    # Extract the image URL from the response
    image_url=$(jq -r '.data.url' <<<"$response")

    printf "%s\n" "$image_url"
}

gbh() {
    typeset -gA branch_color
    branch_color=(
        ["refactor/*"]="\033[38;2;70;117;90m"
        ["security/*"]="\033[38;2;196;35;57m"
        ["chore/*"]="\033[38;2;237;40;158m"
        ["perf/*"]="\033[38;2;40;237;122m"
        ["dev/*"]="\033[38;2;121;48;230m"
        ["feat/*"]="\033[0;92m"
        ["fix/*"]="\033[0;93m"
        ["master"]="\033[0;94m"
        ["main"]="\033[0;94m"
    )

    branch_keys=("feat/*" "fix/*" "refactor/*" "dev/*" "security/*" "perf/*" "chore/*" "master" "main")

    current_branch=$(git branch --show-current)

    git for-each-ref --color=always --sort=-committerdate \
        --format='%(HEAD) %(refname:short) %(color:reset)' refs/heads/ | while read -r branch; do
        if [[ $branch == *"*"* ]]; then
            branch="${branch#* }"
        fi

        for pattern in "${branch_keys[@]}"; do
            if [[ $branch =~ $pattern ]]; then
                frags=($(echo "$branch" | tr '/' ' '))

                if [ ${#frags[@]} = 3 ]; then
                    if [[ "$branch" =~ $current_branch ]]; then
                        branch="${branch_color[$pattern]}${frags[1]}/\033[0m${frags[2]} \033[38;2;93;201;196m← current\033[0m"
                    else
                        branch="${branch_color[$pattern]}${frags[1]}/\033[0m${frags[2]}"
                    fi
                else
                    if [[ "$branch" =~ $current_branch ]]; then
                        branch="${branch_color[$pattern]}${frags[1]}\033[0m \033[38;2;93;201;196m← current\033[0m"
                    else
                        branch="${branch_color[$pattern]}${frags[1]}\033[0m"
                    fi
                fi

                break
            fi
        done

        echo "$branch"
    done
}

billboard() {
    city=$(echo "$1" | xargs | tr '[:upper:]' '[:lower:]')

    get_available_cities() {
        curl --silent http://www.cinerama.com.pe/cines |
            htmlq --pretty .row .container .card .row .col-md-8 .card-body .btn --attribute href |
            awk '{sub("cartelera_cine/",""); print}' | tr '\n' ' '
    }

    # Returns options in case of no passed argument
    if [ -z "$city" ]; then
        cities=$(get_available_cities)
        cities_arr=("$cities")

        reset=$(tput sgr0)

        echo "Options:"

        for city in "${cities_arr[@]}"; do
            color=$((RANDOM % 256))
            color_code=$(tput setaf $color)

            city=$(echo "$city" | sed 's/.*/\L&/; s/[a-zñ]*/\u&/g')
            echo " - ${color_code}${city}${reset}"
        done

        return
    fi

    cinerama_response=$(curl -s -X GET "http://www.cinerama.com.pe/cartelera_cine/$city")
    cinerama_raw_movies=$(echo "$cinerama_response" | htmlq --text .row .container .card .card-header | sed 's/.*/\L&/; s/[a-zñ]*/\u&/g')

    declare -a cinerama_movies_schedules
    index=1

    while read -r schedule; do
        # Sometimes at dawn there's nothing added for the current day
        if [[ "$schedule" == "" ]]; then
            break
        fi

        schedule_timestamp=$(date --date "$schedule" +%s)
        latest_schedules=($(echo "${cinerama_movies_schedules[-1]}" | tr ',' ' '))
        last_unix_schedule=$(date --date "${latest_schedules[-1]}" +%s)

        if [ -z "${latest_schedules[-1]}" ]; then # if last_unix_schedule is null
            cinerama_movies_schedules+=("$(date -d @"$schedule_timestamp" +'%H:%M')")

            continue
        fi

        if [[ $schedule_timestamp > $last_unix_schedule ]]; then
            latest_schedules+=($(date -d @"$schedule_timestamp" +'%H:%M'))
            cinerama_movies_schedules[index]=$(printf '%s\n' "$(IFS=, printf '%s' "${latest_schedules[*]}")")
        else
            cinerama_movies_schedules+=($(date -d @"$schedule_timestamp" +'%H:%M'))
            index=$((index + 1))
        fi

    done <<<"$(echo "$cinerama_response" | htmlq --text .row .container .card .row .col-md-9 .card-body .row .ml-1)"

    printf "\033[38;2;224;29;81m Cinerama:\033[0m\n"
    index=1

    while read -r movie; do
        schedules="${cinerama_movies_schedules[$index]}"

        if [[ "$schedules" == "" ]]; then
            schedules="(not available)"
        fi

        printf " \033[38;2;235;229;66m\033[0m %-50s %s\n" "$movie" "$schedules"
        index=$((index + 1))
    done <<<"$cinerama_raw_movies"
}

remove_node_modules() {
    find . -name "node_modules" -type d -prune -exec rm -rf {} \;
}

# When the current working directory changes, run a method that checks for a .env file, then sources it, thanks johnhamelink
autoload -U add-zsh-hook
load_local_env() {
    # check file exists, is regular file and is readable:
    if [ -f .env ] && [ -r .env ]; then
        source .env
    fi
}

take() {
    mkdir -p "$1"
    cd "$1" || return 1
}

load_local_env
add-zsh-hook chpwd load_local_env

if echo "$(ps -p$$ -ocmd=)" | grep -q "zsh"; then
    hsi() {
        grep "$*" ~/.zsh_history
    }
fi

if [ "$TMUX" = "" ] && [ "$TERM_PROGRAM" != "vscode" ]; then
    exec tmux
fi

#    # Greeting of the date
#    current_date=$(date +%Y-%m-%d)
#    last_startup_date=$(cat /home/$USER/.cache/last_startup_date.txt 2>/dev/null || true)
#
#    if [ "$current_date" != "$last_startup_date" ]; then
#        # This is the first terminal emulator startup of the day
#        tmux send-keys <<EOF
#echo "$current_date" >/home/$USER/.cache/last_startup_date.txt
#echo "HIiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii"
#EOF
#    fi
#
#    unset current_date last_startup_date
