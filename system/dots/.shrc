#!/bin/bash

gbh() {
    typeset -gA branch_color
    branch_color=(
        ['refactor/*']='\033[38;2;70;117;90m'
        ['security/*']='\033[38;2;196;35;57m'
        ['chore/*']='\033[38;2;237;40;158m'
        ['style/*']='\033[38;2;56;93;245m'
        ['perf/*']='\033[38;2;40;237;122m'
        ['docs/*']='\033[38;2;89;87;222m'
        ['dev/*']='\033[38;2;121;48;230m'
        ['ci/*']='\033[38;2;240;222;22m'
        ['feat/*']='\033[0;92m'
        ['master']='\033[0;94m'
        ['fix/*']='\033[0;93m'
        ['main']='\033[0;94m'
    )

    branch_keys=('feat/*' 'fix/*' 'refactor/*' 'ci/*' 'docs/*' 'dev/*' 'security/*' 'perf/*' 'chore/*' 'master' 'main')

    current_branch=$(git branch --show-current)

    git for-each-ref --color=always --sort=-committerdate \
        --format='%(HEAD) %(refname:short) %(color:reset)' refs/heads/ | while read -r branch; do
        if [[ $branch == *"*"* ]]; then
            branch="${branch#* }"
        fi

        for pattern in "${branch_keys[@]}"; do
            if [[ $branch =~ $pattern ]]; then
                frags=($(echo "$branch" | tr '/' ' '))

                if [ ${#frags[@]} = 3 ]; then
                    if [[ "$branch" =~ $current_branch ]]; then
                        branch="${branch_color[$pattern]}${frags[1]}/\033[0m${frags[2]} \033[38;2;93;201;196m← current\033[0m"
                    else
                        branch="${branch_color[$pattern]}${frags[1]}/\033[0m${frags[2]}"
                    fi
                else
                    if [[ "$branch" =~ $current_branch ]]; then
                        branch="${branch_color[$pattern]}${frags[1]}\033[0m \033[38;2;93;201;196m← current\033[0m"
                    else
                        branch="${branch_color[$pattern]}${frags[1]}\033[0m"
                    fi
                fi

                break
            fi
        done

        echo "$branch"
    done
}

hex2ansi() {
    local hex=${1}

    if [[ $hex =~ ^#[0-9A-Fa-f]{6}$ ]]; then
        r=$(printf '%d' 0x"${hex:1:2}")
        g=$(printf '%d' 0x"${hex:3:2}")
        b=$(printf '%d' 0x"${hex:5:2}")

        echo -e "\033[38;2;$r;$g;${b}mplaceholder\033[0m" | command xclip -selection clip
        echo -e "\033[38;2;$r;$g;${b}mCopied to clipboard! \033[0m"
    else
        printf "\033[38;2;240;91;106mInvalid hex color code\033[0m\n"

        return 1
    fi
}

# Refresh the current terminal session(completions and source files)
refresh() {
    autoload -Uz compinit && compinit
    source ~/.dotfiles/system/dots/.zshrc
    source ~/.dotfiles/system/dots/.shrc
}

alias rrr=refresh

gmt() {
    if test -e go.mod; then
        printf "\033[38;2;62;207;168mReviewing modules...\033[0m\n"
        go mod tidy
    else
        printf "\033[38;2;212;42;51mError: go.mod file not found\033[0m\n" >&2
        return 1
    fi
}

# Change between 60 and 100, additionally you can indicate an specific limit
batlimit() {
    new_limit=$1

    if [[ "$new_limit" != "" ]] && [[ ! "$new_limit" =~ ^([1-9]|[1-9][0-9]|100)$ ]]; then
        printf '\033[31mEnter a number between 1 and 100.\033[0m\n'
        return 1
    fi

    current_limit=$(cat /sys/class/power_supply/BAT1/charge_control_end_threshold)

    if [[ $new_limit == '' ]]; then
        if [[ $current_limit == '61' ]]; then
            new_limit='100'
        else
            new_limit='61'
        fi
    fi

    sudo echo "$new_limit" | sudo tee /sys/class/power_supply/BAT1/charge_control_end_threshold >/dev/null

    if ! sudo -nv 2>/dev/null; then
        return 1
    fi

    printf '\033[38;2;92;94;93mOld: \033[0m%s  \033[38;2;39;219;129mNew: \033[0m%s\n' "$current_limit" "$new_limit"
}
